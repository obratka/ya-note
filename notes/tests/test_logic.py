from django.conf import settings
from django.contrib.auth import get_user_model
from django.test import TestCase
from django.urls import reverse
from pytils.translit import slugify

from notes.models import Note

User = get_user_model()


class TestLogic(TestCase):
    @classmethod
    def setUpTestData(cls):
        cls.author = User.objects.create_user(username="author", password="pass12345")
        cls.other = User.objects.create_user(username="other", password="pass12345")

        cls.add_url = reverse("notes:add")
        cls.success_url = reverse("notes:success")

        cls.note = Note.objects.create(
            title="My note", text="Text", slug="my-note", author=cls.author
        )
        cls.edit_url = reverse("notes:edit", args=(cls.note.slug,))
        cls.delete_url = reverse("notes:delete", args=(cls.note.slug,))

    def test_logged_user_can_create_note_anonymous_cannot(self):
        # anonymous -> redirect
        before = Note.objects.count()
        resp = self.client.post(
            self.add_url, data={"title": "T", "text": "X", "slug": "t"}
        )
        self.assertRedirects(resp, f"{settings.LOGIN_URL}?next={self.add_url}")
        self.assertEqual(Note.objects.count(), before)

        # logged in -> create ok
        self.client.login(username="author", password="pass12345")
        before = Note.objects.count()
        resp = self.client.post(
            self.add_url, data={"title": "T2", "text": "X2", "slug": "t2"}
        )
        self.assertEqual(resp.status_code, 302)
        self.assertEqual(Note.objects.count(), before + 1)

    def test_cannot_create_two_notes_with_same_slug(self):
        self.client.login(username="author", password="pass12345")

        # первая уже есть: slug="my-note"
        before = Note.objects.count()
        resp = self.client.post(
            self.add_url,
            data={"title": "Another", "text": "X", "slug": "my-note"},
        )
        self.assertEqual(resp.status_code, 200)  # форма вернулась с ошибкой
        self.assertEqual(Note.objects.count(), before)

        form = resp.context["form"]
        self.assertIn("slug", form.errors)

    def test_slug_autogenerated_if_empty(self):
        self.client.login(username="author", password="pass12345")

        title = "Привет мир"
        before = Note.objects.count()
        resp = self.client.post(self.add_url, data={"title": title, "text": "X", "slug": ""})
        self.assertEqual(resp.status_code, 302)
        self.assertEqual(Note.objects.count(), before + 1)

        created = Note.objects.exclude(pk=self.note.pk).order_by("-id").first()
        expected = slugify(title)[:100]
        self.assertEqual(created.slug, expected)

    def test_user_can_edit_and_delete_own_note(self):
        self.client.login(username="author", password="pass12345")

        resp_edit = self.client.post(
            self.edit_url,
            data={"title": "Updated", "text": "New", "slug": self.note.slug},
        )
        self.assertEqual(resp_edit.status_code, 302)
        self.note.refresh_from_db()
        self.assertEqual(self.note.title, "Updated")
        self.assertEqual(self.note.text, "New")

        resp_delete = self.client.post(self.delete_url)
        self.assertEqual(resp_delete.status_code, 302)
        self.assertFalse(Note.objects.filter(pk=self.note.pk).exists())

    def test_user_cannot_edit_or_delete_foreign_note(self):
        self.client.login(username="other", password="pass12345")

        resp_edit = self.client.post(
            self.edit_url,
            data={"title": "Hacked", "text": "Hacked", "slug": self.note.slug},
        )
        resp_delete = self.client.post(self.delete_url)

        self.assertEqual(resp_edit.status_code, 404)
        self.assertEqual(resp_delete.status_code, 404)

        self.note.refresh_from_db()
        self.assertNotEqual(self.note.title, "Hacked")
        self.assertTrue(Note.objects.filter(pk=self.note.pk).exists())
